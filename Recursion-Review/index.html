<title>CS302 Lecture Notes</title>
<h2>CS302 Lecture Notes - Recursion Review</h2>
<UL>
<LI> September, 2011
<LI> Latest Revision: September, 2020
<LI> James S. Plank
<LI> Directory: <b>/home/plank/cs302/Notes/Recursion-Review</b>
</UL>

This is review and reinforcement of recursion.  
We'll go over three problems that involve recursion in varying levels of
detail.
For primary lecture notes on recursion, please see my
<a href=http://web.eecs.utk.edu/~jplank/plank/classes/cs140/Notes/Recursion/index.html>CS140
Lecture notes on recursion</a>.

<p>
<UL>
<LI> <a href=https://youtu.be/hH96mxjDgf8>Youtube video of me explaining the coins_exchange problem
on 9/3/2020.</a> 
</UL>

<hr>
<h3>#1: Topcoder SRM 355, D2, 550-point problem: NoEights</h3>

As always, I don't re-post their problems.  If their server is down, read the 
problem description from <a href=http://community.topcoder.com/stat?c=problem_statement&pm=7759&rd=10712>http://community.topcoder.com/stat?c=problem_statement&pm=7759&rd=10712</a>.
The gist is, given two numbers, <b>l</b>
and <b>h</b>, determine the minimum number of digits that equal eight for <i>all</i> numbers
between <b>l</b> and <b>h</b> (inclusive).  
<p>
Examples: 
<UL>
<LI> <b>l</b>=1, <b>h</b>=10: The answer is zero, because every number but 8 has zero eights.
<LI> <b>l</b>=8, <b>h</b>=8: Duh.
<LI> <b>l</b>=83848, <b>h</b>=83888: The answer is two -- every number has to start with 838.
<LI> <b>l</b>=83848, <b>h</b>=84888: The answer is one -- every number has to start with 8, but
there are numbers, like 84000, that have only one 8.
</UL>

<h3>Header and Main</h3>

The class definition is in 
<b><a href=include/no_eights.hpp>include/no_eights.hpp</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
<font color=blue>/* Definition of the NoEights class from Topcoder SRM 355, D2, 550 pointer. */</font>

class NoEights {
  public:
    int smallestAmount(int low, int high);
};
</pre></td></table></center><p>

I have a driver program in 
<b><a href=src/no_eights_main.cpp>src/no_eights_main.cpp</a></b>.  If you give it 0, 1, 2
or 3 on the command line, it will do that Topcoder example.  If you give it "-", then it 
will read <b>l</b> and <b>h</b> from standard input.

<p>
The makefile compiles <b>src/no_eights_main.cpp</b> with <b>src/no_eights.cpp</b> to 
make 
<b>bin/no_eights</b>:

<pre>
UNIX> <font color=darkred><b>make clean</b></font>
rm -f a.out obj/* bin/*
UNIX> <font color=darkred><b>make bin/no_eights</b></font>
g++ -std=c++98 -O3 -Wall -Wextra -Iinclude -c -o obj/no_eights_main.o src/no_eights_main.cpp
g++ -std=c++98 -O3 -Wall -Wextra -Iinclude -c -o obj/no_eights.o src/no_eights.cpp
g++ -std=c++98 -O3 -Wall -Wextra -Iinclude -o bin/no_eights obj/no_eights_main.o obj/no_eights.o
UNIX> <font color=darkred><b></b></font>
</pre>

<hr>
<h3>Solving this with recursion</h3>

The brain dead way to do this is to iterate from <b>l</b> to <b>h</b>, counting eights.  
Unfortunately, the  constraints on the problem say that <b>l</b> and <b>h</b> can be up
to 2,000,000,000, so that's too slow.
<p>
The key insight is to look at <b>l</b> and <b>h</b> as strings with equal numbers of digits.
Then, the common prefixes of <b>l</b> and <b>h</b> allow us to determine the minimum
number of eights.
The problem description says that
<b>h</b> will be at most a 10-digit number, so simply convert both to 10-digit strings
that represent the numbers with leading zeros.  
<p>
In other words, if <b>l</b> equals 8 and <b>h</b> equals 20, then convert <b>l</b> to
"0000000008" and <b>h</b> to "0000000020".
<p>
Now, look at the first digit of both numbers.  Call them <b>h[0]</b> and <b>l[0]</b>.  
If both equal '8', then every number between <b>h</b> and <b>l</b>
has to start with '8'.  If we remove the '8' from both strings and solve the problem 
recursively, then our answer is one plus the answer of the recursive problem.
<p>
Instead, suppose they both do not equal '8', but they do equal each other.  If we remove
the digit from both numbers and solve it recursively, then we have the answer. 
<p>
Suppose they do not equal each other, and <b>h[0]</b> does not equal '8'.  Then,
you know the number beginning with <b>h[0]</b> and having zero's in every other digit is 
between <b>l</b> and <b>h</b>, and it has zero 8's.  You can return zero.  
<p>
Suppose they do not equal each other, and <b>h[0]</b> equals '8'.  Then,
you know the number beginning with <b>l[0]</b> and having nines in every other digit is 
between <b>l</b> and <b>h</b>, and it has zero 8's.  You can return zero again. 
<p>
This maps itself to a straightforward solution, in
<b><a href=src/no_eights.cpp>src/no_eights.cpp</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
int NE(const string &l, const string &h, size_t index)
{
  if (index == l.size()) return 0;     <font color=blue>// Base case when we have no digits left.</font>
  if (l[index] != h[index]) return 0;

  if (l[index] == '8') return 1 + (NE(l, h, index+1));
  return 0 + (NE(l, h, index+1));
}

int NoEights::smallestAmount(int low, int high)
{
  char b[20];
  string l, h;

  sprintf(b, "%010d", low);    <font color=blue>// Conversion to 10 digit strings with leading zeros</font>
  l = b;
  sprintf(b, "%010d", high);
  h = b;
  return NE(l, h, 0);
}
</pre></td></table></center><p>

Now, you could have solved that with a <b>for</b> loop, but sometimes it's easier to think
recursively.  What's the running time?  It's <i>O(n)</i>, where <i>n</i> is the length of
the string. 

<pre>
UNIX> <font color=darkred><b>bin/no_eights 0</b></font>
0
UNIX> <font color=darkred><b>bin/no_eights 1</b></font>
2
UNIX> <font color=darkred><b>bin/no_eights 2</b></font>
1
UNIX> <font color=darkred><b>bin/no_eights 3</b></font>
2
UNIX> <font color=darkred><b>echo 80888 80899 | bin/no_eights -</b></font>
2
UNIX> <font color=darkred><b></b></font>
</pre>


<hr>
<h3>#2: Topcoder SRM 351, D1, 250-point problem: CoinsExchange</h3>

The problem description is available at <a href=http://community.topcoder.com/stat?c=problem_statement&pm=7773&rd=10675>http://community.topcoder.com/stat?c=problem_statement&pm=7773&rd=10675</a>.
<p>
We are given six numbers: <b>G1</b>, <b>S1</b> and <b>B1</b>, representing the number
of gold, silver and bronze coins that we currently have, and 
<b>G2</b>, <b>S2</b> and <b>B2</b>, representing the number
of gold, silver and bronze coins that we want to have.  We have exchange rates:
<p>
<UL>
<LI> If you give the bank one gold, you get 9 silver
<LI> If you give the bank 11 silver, you get one gold
<LI> If you give the bank one silver, you get 9 bronze
<LI> If you give the bank 11 bronze, you get one silver
</UL>

We are to return the minimum number of exchanges that we need to perform to get
at least <b>G2/S2/B2</b> from <b>G1/S1/B1</b>.    Here are the examples:

<hr>
<pre>
Example   G1  S1  B1    G2  S2  B2   Answer
  0        1   0   0     0   0  81     10: One gold to 9 silver.  9 silver to 81 bronze.
  1        1 100  12     5  53  33      7: 44 silver to 4 gold.  3 silver to 27 gold.
  2        1 100  12     5  63  33     -1: Impossible.
  3        5  10  12     3   7   9      0: Got already.
</pre>
<hr>
<h3>Header and Driver</h3>

As with the other topcoder problems in these lectures, I have a header
and driver.  The header is in 
<b><a href=include/coins_exchange.hpp>include/coins_exchange.hpp</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
<font color=blue>/* Header file for Topcoder SRM 351, D1, 250-Pointer: CoinsExchange */</font>

#include &lt;string&gt;

class CoinsExchange {
  public:
    int countExchanges(int G1, int S1, int B1, int G2, int S2, int B2);

  protected:               <font color=blue>/* I've added this variable to help print out the state. */</font>
    std::string nest;
};
</pre></td></table></center><p>

And the driver is
<b><a href=src/coins_exchange_main.cpp>src/coins_exchange_main.cpp</a></b>.  You can give
it the coins on standard input if you give it a dash on the command line.  Otherwise, you 
can give it example numbers on the command line.

<h3>Working Up To A Solution</h3>

In 2020, I messed up this program for something like the 10th time in the 13 times that I
have taught this lecture.  So, yet another rewrite -- I vow never to mess this program
up again!!!  
<p>
I have two versions of this program.  The version in
<b><a href=src/coins_exchange.cpp>src/coins_exchange.cpp</a></b> is commented, but
doesn't print out anything.  The version in 
<b><a href=src/coins_exchange_print.cpp>src/coins_exchange_print.cpp</a></b> prints
out what it's doing.  I suggest, when you are studying this program, you work up to a solution
with me in the way I'm doing below.  You can assure yourself of what's going on with the
version that prints information.
<p>
The approach that I take is to 
break the problem into sub-problems and then use recursion to solve the sub problems.
Each time I do so, I make the sub-problems easier.
That's a lot easier than trying to think things like: "If <b>G2</b> is greater than <b>G1</b> 
but 11*<b>(G2-G1)</b> is greater than <b>(S1-S2)</b>, then.....".
<p>
I'm going to show you here how I solve the problem.  To start with, I'm going to declare
some extra variables which help me think through the problem.  These are the excess gold,
silver and bronze that I have, and the deficits of gold, silver and bronze that I have.
I'm going to start by calculating them, and if I have no deficits, then I'm already done --
I'll return zero.  Otherwise, I'll return -1.

<p><center><table border=3 cellpadding=3><td><pre>
int CoinsExchange::countExchanges(int G1, int S1, int B1, int G2, int S2, int B2)
{
  int gold_excess, silver_excess, bronze_excess;      <font color=blue>// Excess coins</font>
  int gold_deficit, silver_deficit, bronze_deficit;   <font color=blue>// Coins where I have a deficit</font>

  <font color=blue>/* Determine our deficit coins and our excess coins. */</font>

  gold_deficit = (G2 - G1 &gt; 0) ? G2 - G1 : 0;
  gold_excess  = (G1 - G2 &gt; 0) ? G1 - G2 : 0;

  silver_deficit = (S2 - S1 &gt; 0) ? S2 - S1 : 0;
  silver_excess  = (S1 - S2 &gt; 0) ? S1 - S2 : 0;

  bronze_deficit = (B2 - B1 &gt; 0) ? B2 - B1 : 0;
  bronze_excess  = (B1 - B2 &gt; 0) ? B1 - B2 : 0;

  <font color=blue>/* Base case -- if there are no deficits, then return 0. */</font>

  if (gold_deficit == 0 && silver_deficit == 0 && bronze_deficit == 0) {
    printf("Our needs are met -- returning 0\n");
    return 0;
  }

  <font color=blue>/* If we have reached this point, then it's impossible, or we haven't implemented it. */</font>

  return -1;
}
</pre></td></table></center><p>

We'll test this four times -- comments inline:

<pre>
UNIX> <font color=darkred><b>echo 10 20 30   5 5 30 | bin/coins_exchange -      <font color=blue> # We have enough of everything</b></font></font>
0
UNIX> <font color=darkred><b>echo 10 20 30   11 5 30 | bin/coins_exchange -     <font color=blue> # Too little gold</b></font></font>
-1
UNIX> <font color=darkred><b>echo 10 20 30   5 21 30 | bin/coins_exchange -     <font color=blue> # Too little silver</b></font></font>
-1
UNIX> <font color=darkred><b>echo 10 20 30   5 5 31 | bin/coins_exchange -      <font color=blue> # Too little bronze</b></font></font>
-1
UNIX> <font color=darkred><b></b></font>
</pre>

<h4>Start with Gold</h4>

Now, we'll start with gold.  If we have a deficit of gold, then we'll need to get it from
silver.  We'll introduce a new variable, <b>need_silver</b> to represent how much silver
we need (it will be 11 times our gold deficit).  And we'll call <b>countExchanges()</b>
recursively, removing gold from the equation and adding <b>need_silver</b> to our silver
needs.  That will return how many transactions were needed to make sure we have enough
silver (or that it was impossible).  We add <b>gold_deficit</b> to that to account for
the exchanges of silver to gold, and return the sum.  
<p>
Here's the code:

<p><center><table border=3 cellpadding=3><td><pre>
  <font color=blue>/* First issue -- if we need gold, we have to get it from silver.
     So, calculate how much silver we need, and make a recursive call to
     see how many transactions are needed to get it.  If it's possible,
     then add the number of transactions for the gold (which is the number of
     gold we need) and return it.  */</font>

  if (gold_deficit &gt; 0) {
    need_silver = 11 * gold_deficit;
    rv = countExchanges(0, S1, B1, 0, S2+need_silver, B2);
    if (rv == -1) return -1;
    return rv+gold_deficit;
  }
}
</pre></td></table></center><p>

Let's test:

<pre>
UNIX> <font color=darkred><b>echo 10 111 0   20 0 0 | bin/coins_exchange -   <font color=blue> # We have enough silver.</b></font></font>
10
UNIX> <font color=darkred><b>echo 10 109 0   20 0 0 | bin/coins_exchange -   <font color=blue> # We don't have enough silver.</b></font></font>
-1
UNIX> <font color=darkred><b></b></font>
</pre>

If you want more detail on the recursion, call <b>bin/count_exchanges_print</b>.  This
tells you about the recursive calls:

<pre>
UNIX> <font color=darkred><b>echo 10 111 0   20 0 0 | bin/coins_exchange_print -</b></font>
We have:  G1:  10   S1: 111   B1:   0
We want:  G2:  20   S2:   0   B2:   0

Our gold deficit is 10 and we need 110 silver.  Making a recursive call.

We have:  G1:   0   S1: 111   B1:   0   <font color=blue> # The recursive call removes all of the gold.</font>
We want:  G2:   0   S2: 110   B2:   0   <font color=blue> # and add's the silver needed to the silver</font>

Our needs are met -- returning 0        <font color=blue> # Since we have enough silver, we can return with zero exchanges</font>

We recursively got 110 silver to convert to 10 gold.  RV=0.  Returning 0+10 = 10

10
UNIX> <font color=darkred><b>echo 10 109 0   20 0 0 | bin/coins_exchange_print -</b></font>
We have:  G1:  10   S1: 109   B1:   0
We want:  G2:  20   S2:   0   B2:   0

Our gold deficit is 10 and we need 110 silver.  Making a recursive call.

We have:  G1:   0   S1: 109   B1:   0    <font color=blue> # Now, in the recursive call, we don't have enough silver.</font>
We want:  G2:   0   S2: 110   B2:   0

It's impossible
-1
UNIX> <font color=darkred><b></b></font>
</pre>

<h4>Bronze</h4>

Let's do the same thing with bronze -- if we have a deficit of bronze, then we need
to get it from silver.  Integer division helps us here.  Since we get 9 bronze for
each silver, we need:

<UL>
<LI> 1 silver to get between 1 and 9 bronze.
<LI> 2 silver to get between 10 and 18 bronze.
<LI> 3 silver to get between 19 and 27 bronze.
<LI> And so on.
</UL>

If you think about it a bit, you calculate your silver needs, by adding 8 to the bronze and
dividing by nine using integer division.  The bronze code looks similar to the gold code,
except the number of transactions is the number of silver that you convert:

<p><center><table border=3 cellpadding=3><td><pre>
  <font color=blue>/* Second issue -- if we need bronze, then we also have to get it from silver.
     So, calculate how much silver we need, and make a recursive call to
     see how many transactions are needed to get it.  If it's possible,
     then add the number of transactions for the bronze (which is the number of
     silver that we exchanged) and return it.  */</font>

  if (bronze_deficit &gt; 0) {
    need_silver = (bronze_deficit + 8) / 9;
    rv = countExchanges(G1, S1, 0, G2, S2+need_silver, 0);
    if (rv == -1) return -1;
    return rv+need_silver;
  }
</pre></td></table></center><p>

Test.  If you want more detail, 
<a href=html/bronze_test.html>This link has the calls with printing.</a>

<pre>
UNIX> <font color=darkred><b>echo 0 5 0   0 0 44 | bin/coins_exchange -    <font color=blue> # We get 45 bronze for 5 silver.</b></font></font>
5
UNIX> <font color=darkred><b>echo 0 5 0   0 0 45 | bin/coins_exchange -    <font color=blue> # This works, too</b></font></font>
5
UNIX> <font color=darkred><b>echo 0 5 0   0 0 46 | bin/coins_exchange -    <font color=blue> # Now, we need 6 silver.</b></font></font>
-1
UNIX> <font color=darkred><b></b></font>
</pre>

<h4>Silver</h4>

Now we need to work on silver.  This is a little more subtle.  Since we can get more silver
with gold, we first see if we can satisfy silver with gold.  If we can, we're done.
If we can't, then we need to get more silver from bronze.  We do that recursively:

<p><center><table border=3 cellpadding=3><td><pre>
  <font color=blue>/* If we have reached this point, we need silver.  If we have excess gold,
     let's get as much silver as we can from gold.  If that solves the problem,
     then we return.  If it doesn't then we recursively solve it, taking gold
     out of the equation. */</font>

  if (gold_excess &gt; 0) {
    need_gold = (silver_deficit + 8) / 9;
    if (need_gold &lt;= gold_excess) return need_gold;
    rv = countExchanges(0, S1, B1, 0, S2-gold_excess*9, B2);
    if (rv == -1) return -1;
    return gold_excess+rv;
  }
}
</pre></td></table></center><p>

Test (with printing is in <a href=html/silver_1_test.html>this link</a>):

<pre>
UNIX> <font color=darkred><b>echo 10 0 0   0 90 0 | bin/coins_exchange -        <font color=blue> # Get 90 silver from 10 gold.</b></font></font>
10
UNIX> <font color=darkred><b>echo 10 0 0   0 0 810 | bin/coins_exchange -       <font color=blue> # Bronze makes a recursive call for</b></font></font>
100 <b>                                                     <font color=blue> # 90 silver, which takes 10 gold.</font></b>
UNIX> <font color=darkred><b>echo 10 0 0   0 91 0 | bin/coins_exchange -        <font color=blue> # This one is impossible</b></font></font>
-1
UNIX> <font color=darkred><b>echo 10 0 0   0 0 811 | bin/coins_exchange -       <font color=blue> # As is this one.</b></font></font>
-1
UNIX> <font color=darkred><b></b></font>
</pre>

And finally, the last case is getting silver from bronze.  If we don't have enough bronze,
then we fail.

<p><center><table border=3 cellpadding=3><td><pre>
  <font color=blue>/* Now, if we have reached this point, we need silver and we have no gold.  We have
     to get it from bronze. */</font>


  need_bronze = silver_deficit * 11;
  if (need_bronze &lt;= bronze_excess) return silver_deficit;

  <font color=blue>/* If we have reached this point, then it's impossible. */</font>
  return -1;
}
</pre></td></table></center><p>

Test -- we'll do all of the topcoder tests, too! (with printing <a href=html/silver_2_test.html>here)</a>.

<pre>
UNIX> <font color=darkred><b>echo 0 0 110    0 10 0  | bin/coins_exchange -</b></font>
10
UNIX> <font color=darkred><b>echo 0 0 109    0 10 0  | bin/coins_exchange -</b></font>
-1
UNIX> <font color=darkred><b>echo 0 0 121    1 0 0  | bin/coins_exchange -</b></font>
12
UNIX> <font color=darkred><b>echo 0 0 120    1 0 0  | bin/coins_exchange -</b></font>
-1
UNIX> <font color=darkred><b>bin/coins_exchange 0</b></font>
10
UNIX> <font color=darkred><b>bin/coins_exchange 1</b></font>
7
UNIX> <font color=darkred><b>bin/coins_exchange 2</b></font>
-1
UNIX> <font color=darkred><b>bin/coins_exchange 3</b></font>
0
UNIX> <font color=darkred><b></b></font>
</pre>

We're done -- my goal here was to show you how recursion can help you break a problem
into subproblems that you can solve recursively.  

<hr>
<h3>#3: Solving Sudoku Puzzles</h3>

I assume everyone knows what sudoku is, but if you don't, read
<a href=http://en.wikipedia.org/wiki/Sudoku>Wikipedia's page</a>.  
Since the problems are pretty small, it's very easy to write a brain-dead
recursive Sudoku solver, and for hard problems, it's easier to write the
program than it is to solve the puzzle by hand!  I go over this program
rather quickly, because we've done Sudoku in CS140 as well.
It's a nice use of recursion.
<p>
We'll build a solution.  First have to read a problem in -- I'll do that from 
standard input -- numbers are '1' through '9', empty cells are '-' and everything else is
ignored.  I store a puzzle in a vector of nine strings, each with nine characters.
I do this in a <b>Read()</b> method of a class called <b>Sudoku</b>, and I also 
implement a <b>Print()</b> method in 
<b><a href=src/sudoku1.cpp>src/sudoku1.cpp</a></b>:

<p><center><table border=3 cellpadding=3><td valign=top><pre>
class Sudoku {
  public:
    void Read();            <font color=blue>// Read from standard input</font>
    void Print() const;     <font color=blue>// Print to standard output</font>
  protected:
    vector &lt;string&gt; puzzle; <font color=blue>// Hold the puzzle in a vector of 9 strings</font>
};

void Sudoku::Read()        
{
  int i, j;
  char c;

  puzzle.clear();
  puzzle.resize(9);

  for (i = 0; i &lt; 9; i++) {  <font color=blue>// Read the puzzle, error checking.</font>
    for (j = 0; j &lt; 9; j++) {
      do {
        if (!(cin &gt;&gt; c)) { 
          cerr &lt;&lt; "Not enough cells.\n";
          exit(1);
        }
      } while (isspace(c));
      if (c != '-' && (c &lt; '1' || c &gt; '9')) {
        cerr &lt;&lt; "Bad character " &lt;&lt; c &lt;&lt; endl;
        exit(1);
      }
      puzzle[i].push_back(c);
    }
  }
}
</pre></td><td valign=top><pre>
void Sudoku::Print() const
{
  int i, j;

  for (i = 0; i &lt; puzzle.size(); i++) {
    for (j = 0; j &lt; puzzle[i].size(); j++) {
      cout &lt;&lt; puzzle[i][j];
      if (j == 2 || j == 5) cout &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
    if (i == 2 || i == 5) cout &lt;&lt; endl;
  }
}
  
int main()
{
  Sudoku S;

  S.Read();
  S.Print();
}
</pre></td></table></center><p>

I have the example from the Wikipedia page in two files:
<b><a href=txt/sudex1.txt>txt/sudex1.txt</a></b> and
<b><a href=txt/sudex2.txt>txt/sudex2.txt</a></b>.  They differ in the amount of whitespace.
However, when the program reads them in, they produce the same output:

<p><center><table border=3><td valign=top><pre>
UNIX> <font color=darkred><b>make bin/sudoku1</b></font>
g++ -std=c++98 -O3 -o bin/sudoku1 src/sudoku1.cpp 
UNIX> <font color=darkred><b>cat txt/sudex1.txt</b></font>
53--7----
6--195---
-98----6-
8---6---3
4--8-3--1
7---2---6
-6----28-
---419--5
----8--79
UNIX> <font color=darkred><b>bin/sudoku1 < txt/sudex1.txt</b></font>
53- -7- ---
6-- 195 ---
-98 --- -6-

8-- -6- --3
4-- 8-3 --1
7-- -2- --6

-6- --- 28-
--- 419 --5
--- -8- -79
UNIX>
</pre>
</td><td valign=top>
<pre>
UNIX> <font color=darkred><b>cat txt/sudex2.txt</b></font>
5 3 -   - 7 -   - - - 
6 - -   1 9 5   - - - 
- 9 8   - - -   - 6 - 

8 - -   - 6 -   - - 3 
4 - -   8 - 3   - - 1 
7 - -   - 2 -   - - 6 

- 6 -   - - -   2 8 - 
- - -   4 1 9   - - 5 
- - -   - 8 -   - 7 9 
UNIX> <font color=darkred><b>bin/sudoku1 < txt/sudex2.txt</b></font>
53- -7- ---
6-- 195 ---
-98 --- -6-

8-- -6- --3
4-- 8-3 --1
7-- -2- --6

-6- --- 28-
--- 419 --5
--- -8- -79
UNIX> <font color=darkred><b></b></font>
</pre>
</td></table></center><p>

As a next step, we implement methods to check whether rows, columns or 
panels are valid.   They are straightforward.  In 
<b><a href=src/sudoku2.cpp>src/sudoku2.cpp</a></b>, we check to see whether the 
input matrix is indeed valid.

<p>
In class, I pause here and ask you to write the <b>row_ok()</b> method.
Read <a href=html/row_ok.html>this page</a> for a discussion of various
bad ways to write <b>row_ok()</b>.

<p><center><table border=3 cellpadding=3><td valign=top><pre>
class Sudoku {
  public:
    void Read();                        <font color=blue>// Read from standard input</font>
    void Print() const;                 <font color=blue>// Print to standard output</font>
    int row_ok(int r) const;            <font color=blue>// Test row r for correctness</font>
    int column_ok(int c) const;         <font color=blue>// Test cols r for correctness</font>
    int panel_ok(int pr, int pc) const; <font color=blue>// Test panel pr/pc (both 0,1,2) for correctness</font>
  protected:
    vector &lt;string&gt; puzzle;             <font color=blue>// Hold the puzzle in a vector of 9 strings</font>
};

int Sudoku::row_ok(int r) const
{
  vector &lt;int&gt; checker;     <font color=blue>/* Use this to make sure no digit is set twice. */</font>
  int c;

  checker.clear();
  checker.resize(10, 0);
  for (c = 0; c &lt; 9; c++) {
    if (puzzle[r][c] != '-') {
      if (checker[puzzle[r][c]-'0']) return 0;
      checker[puzzle[r][c]-'0'] = 1;
    }
  }
  return 1;
}
   
int Sudoku::column_ok(int c) const
{
  vector &lt;int&gt; checker;
  int r;

  checker.resize(10, 0);
  for (r = 0; r &lt; 9; r++) {
    if (puzzle[r][c] != '-') {
      if (checker[puzzle[r][c]-'0']) return 0;
      checker[puzzle[r][c]-'0'] = 1;
    }
  }
  return 1;
}

int Sudoku::panel_ok(int pr, int pc) const
{
  vector &lt;int&gt; checker;
  int r, c;
  int i, j;

  checker.resize(10, 0);
  for (i = 0; i &lt; 3; i++) {
    for (j = 0; j &lt; 3; j++) {
      r = pr*3+i;
      c = pc*3+j;
      if (puzzle[r][c] != '-') {
        if (checker[puzzle[r][c]-'0']) return 0;
        checker[puzzle[r][c]-'0'] = 1;
      }
    }
  }
  return 1;
}

int main()
{
  int r, c;
  Sudoku S;

  S.Read();

  for (r = 0; r &lt; 9; r++) if (!S.row_ok(r)) printf("Bad row %d\n", r);
  for (c = 0; c &lt; 9; c++) if (!S.column_ok(c)) printf("Bad col %d\n", c);
  for (r = 0; r &lt; 3; r++) for (c = 0; c &lt; 3; c++) {
    if (!S.panel_ok(r, c)) printf("Bad panel %d %d\n", r, c);
  }
}
</pre></td></table></center><p>

I have some example puzzles 
(<b><a href=txt/sudex3.txt>txt/sudex3.txt</a></b>,
<b><a href=txt/sudex4.txt>txt/sudex4.txt</a></b> &amp;
<b><a href=txt/sudex5.txt>txt/sudex5.txt</a></b>)
with errors: the program 
correctly identifies them:

<pre>
UNIX> <font color=darkred><b>make bin/sudoku2</b></font>
g++ -std=c++98 -O3 -o bin/sudoku2 src/sudoku2.cpp 
UNIX> <font color=darkred><b>bin/sudoku2 < txt/sudex3.txt</b></font>
Bad row 3
UNIX> <font color=darkred><b>bin/sudoku2 < txt/sudex4.txt</b></font>
Bad col 7
UNIX> <font color=darkred><b>bin/sudoku2 < txt/sudex5.txt</b></font>
Bad panel 1 2
UNIX> <font color=darkred><b></b></font>
</pre>

Now, this gives us all the pieces to write a really brain-dead recursive 
solver.  What it does is the following:
<p>
<UL>
<LI> It finds an empty cell.
<LI> It tests every value from 1 to 9 in the cell.
<LI> If the value yields a legal row, column and panel, it calls itself
recursively.
<LI> If the recursive call reports that it failed, then it will remove the
value from the cell, and test the next value.  If there is no "next value",
then it returns failure.
</UL>

If it is called on a filled puzzle, we're done -- we print it and exit, and
don't return to our callers.
The code is in 
<b><a href=src/sudoku3.cpp>src/sudoku3.cpp</a></b>

<p><center><table border=3 cellpadding=3><td><pre>
class Sudoku {
  public:
    void Read();                        <font color=blue>// Read from standard input</font>
    void Print() const;                 <font color=blue>// Print to standard output</font>
    void Solve();                       <font color=blue>// Solve the problem</font>
    int row_ok(int r) const;            <font color=blue>// Test row r for correctness</font>
    int column_ok(int c) const;         <font color=blue>// Test cols r for correctness</font>
    int panel_ok(int pr, int pc) const; <font color=blue>// Test panel pr/pc (both 0,1,2) for correctness</font>
  protected:
    vector &lt;string&gt; puzzle;             <font color=blue>// Hold the puzzle in a vector of 9 strings</font>
};

void Sudoku::Solve()
{
  int r, c, i;

  for (r = 0; r &lt; 9; r++) {
    for (c = 0; c &lt; 9; c++) {
      if (puzzle[r][c] == '-') {         <font color=blue>/* Find the first empty cell. */</font>
        for (i = '1'; i &lt;= '9'; i++) {   <font color=blue>/* Try every digit. */</font>
          puzzle[r][c] = i;              <font color=blue>/* If the digit is legal, call Solve() recursively */</font>
          if (row_ok(r) && column_ok(c) && panel_ok(r/3, c/3)) Solve();
        }
        puzzle[r][c] = '-';
        return;
      }
    }
  }
  Print();             <font color=blue>/* If we get here, the puzzle has been solved. */</font>
  exit(0);
}
</pre></td></table></center><p>

It works on our example, pretty quickly (at this point, I'm assuming that you have
made all of the executables).

<pre>
UNIX> <font color=darkred><b>time bin/sudoku3 < txt/sudex1.txt</b></font>
534 678 912
672 195 348
198 342 567

859 761 423
426 853 791
713 924 856

961 537 284
287 419 635
345 286 179
0.043u 0.001s 0:00.04 100.0%	0+0k 0+0io 0pf+0w
UNIX> <font color=darkred><b></b></font>
</pre>

I find that a little depressing, actually, that a program that brain-dead can
solve a puzzle in seconds that may take me 10+ minutes of logic and head-scratching.
<p>
However, if you're like me, it seems like we could speed this up.  Let's explore.

<hr>
<h3>Speeding it up a little</h3>

First, we need a way to test speed.  What I've done is grab six "Evil" puzzles
from a web site.  They are in
<b><a href=txt/test_puzzle_1.txt>txt/test_puzzle_1.txt</a></b>,
<b><a href=txt/test_puzzle_2.txt>txt/test_puzzle_2.txt</a></b>,
<b><a href=txt/test_puzzle_3.txt>txt/test_puzzle_3.txt</a></b>,
<b><a href=txt/test_puzzle_4.txt>txt/test_puzzle_4.txt</a></b>,
<b><a href=txt/test_puzzle_5.txt>txt/test_puzzle_5.txt</a></b> and
<b><a href=txt/test_puzzle_6.txt>txt/test_puzzle_6.txt</a></b>.
I first compile the program using optimization, and then I time it on the six programs
with a fancy shell command:

<pre>
UNIX> <font color=darkred><b>g++ -O3 -o bin/sudoku3 src/sudoku3.cpp</b></font>
UNIX> <font color=darkred><b>time sh -c 'for i in 1 2 3 4 5 6 ; do bin/sudoku3 < txt/test_puzzle_$i.txt > /dev/null; done'</b></font>
0.430u 0.000s 0:00.42 102.3%  0+0k 0+0io 0pf+0w
UNIX> <font color=darkred><b></b></font>
</pre>

Roughly 0.07 seconds for each test.  What's one easy way to speed this up?  Well, it
seems a bit inefficient to look for a blank space from the beginning each time we
call <b>Solve()</b>.  Let's instead parameterize <b>Solve()</b> with the row and column,
and then when we call it recursively, we give it the next cell.  The updated
<b>Solve()</b> is in 
<b><a href=src/sudoku4.cpp>src/sudoku4.cpp</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
void Sudoku::Solve(int r, int c)
{
  int i;

  if (c == 9) { c = 0; r++; }

  while (r &lt; 9) {
    if (puzzle[r][c] == '-') {
      for (i = '1'; i &lt;= '9'; i++) {
        puzzle[r][c] = i;
        if (row_ok(r) && column_ok(c) && panel_ok(r/3, c/3)) Solve(r, c+1);
      }
      puzzle[r][c] = '-';
      return;
    }
    c++;
    if (c == 9) { c = 0; r++; }
  }
  Print();
  exit(0);
}
</pre></td></table></center><p>

We first call it with <b>Solve(0, 0)</b>.  Does it speed things up?  A little:

<pre>
UNIX> <font color=darkred><b>time sh -c 'for i in 1 2 3 4 5 6 ; do bin/sudoku4 < txt/test_puzzle_$i.txt > /dev/null; done'</b></font>
0.420u 0.000s 0:00.40 105.0%  0+0k 0+0io 0pf+0w
UNIX> <font color=darkred><b></b></font>
</pre>

I'm surprised that it doesn't speed matters up more.  Whatever.  Let's try 
something more drastic.  For each row, column and panel, let's keep a set of 
valid numbers that can be entered.  Then, we have two potential speed-ups.
First, when we want to test an empty cell, we can traverse the legal values
for the cell's row, then test the column & panel sets to see if the value is
legal for those too.  If so, we can call <b>Solve()</b> recursively.  
That eliminates the calls to <b>row_ok()</b>, <b>column_ok()</b> and <b>panel_ok()</b>.
<p>
The code is a bit icky -- it's in 
<b><a href=src/sudoku5.cpp>src/sudoku5.cpp</a></b>.  First, here's the updated 
class definition:


<p><center><table border=3 cellpadding=3><td><pre>
typedef set &lt;int&gt; ISet;
typedef vector &lt;ISet&gt; VISet;

class Sudoku {
  public:
    vector &lt;string&gt; puzzle;             <font color=blue>// Hold the puzzle in a vector of 9 strings</font>
    void Read();                        <font color=blue>// Read from standard input</font>
    void Print() const;                 <font color=blue>// Print to standard output</font>
    void Solve(int r, int c);           <font color=blue>// Solve starting at the given row/col</font>
    int row_ok(int r) const;            <font color=blue>// Test row r for correctness</font>
    int column_ok(int c) const;         <font color=blue>// Test cols r for correctness</font>
    int panel_ok(int pr, int pc) const; <font color=blue>// Test panel pr/pc (both 0,1,2) for correctness</font>
    vector &lt;ISet&gt; vrows;       <font color=blue>// Sets of legal values for each row.</font>
    vector &lt;ISet&gt; vcols;       <font color=blue>// Sets of legal values for each row.</font>
    vector &lt;VISet&gt; vpanels;    <font color=blue>// Sets of legal values for each panel.</font>
};
</pre></td></table></center><p>

And here's <b>Solve()</b>:

<p><center><table border=3 cellpadding=3><td><pre>
void Sudoku::Solve(int r, int c)
{
  int i, j, e;
  vector &lt;int&gt; to_try;
  ISet::iterator rit, cit, pit;

  <font color=blue>/* At the beginning, first put all values into the three vectors of sets: */</font>

  if (r == 0 && c == 0) {
    vrows.resize(9);
    vcols.resize(9);
    vpanels.resize(3);
    for (i = 0; i &lt; 3; i++) vpanels[i].resize(3);

    for (i = 0; i &lt; 9; i++) {
      for (j = '1'; j &lt;= '9'; j++) {
        vrows[i].insert(j);
        vcols[i].insert(j);
        vpanels[i/3][i%3].insert(j);
      }
    }
    
    <font color=blue>/* Then, run through each row, column and panel of the puzzle,
       and remove values from the sets. */</font>

    for (i = 0; i &lt; 9; i++) {
      for (j = 0; j &lt; 9; j++) {
        if (puzzle[i][j] != '-') {
          e = puzzle[i][j];
          vrows[i].erase(vrows[i].find(e));
          vcols[j].erase(vcols[j].find(e));
          vpanels[i/3][j/3].erase(vpanels[i/3][j/3].find(e));
        }
      }
    }
  }
      
  if (c == 9) { c = 0; r++; }

  <font color=blue>/* Now, instead of trying every value and testing for legality, we instead create
     a vector from all of the legal values in the row.  We traverse that vector, and
     if a value is legal in the column and panel, then we add it to the puzzle and
     remove it from the three sets.  Then we make the recursive call, and add the value
     back to the sets.  This code is kind of a pain, isn't it? */</font>

  while (r &lt; 9) {
    if (puzzle[r][c] == '-') {
      for(rit = vrows[r].begin(); rit != vrows[r].end(); rit++) to_try.push_back(*rit);
      for (i = 0; i &lt; (int) to_try.size(); i++) {
        e = to_try[i];
        cit = vcols[c].find(e);
        if (cit != vcols[c].end()) {
          pit = vpanels[r/3][c/3].find(e);
          if (pit != vpanels[r/3][c/3].end()) {
            rit = vrows[r].find(e);
            vrows[r].erase(rit);
            vcols[c].erase(cit);
            vpanels[r/3][c/3].erase(pit);
            puzzle[r][c] = e;
            Solve(r, c+1);
            vrows[r].insert(e);
            vcols[c].insert(e);
            vpanels[r/3][c/3].insert(e);
          }
        }
      }
      puzzle[r][c] = '-';
      return;
    }
    c++;
    if (c == 9) { c = 0; r++; }
  }
  Print();
  exit(0);
}
</pre></td></table></center><p>

Although a bit spindly, the code is straightforward.
The only subtlety that I see is using <b>to_try</b>.
Why did I do this?  Why didn't I simply use <b>rit</b> to traverse <b>vrows[r]</b>?
The reason is that I potentially erase <b>rit</b> inside the loop -- once I do that,
I invalidate <b>rit</b>, which would be problematic inside a <b>for</b> loop that
uses <b>rit</b>.  Yes, I could store <b>rit++</b> and change the loop -- that's probably
faster; however, using <b>to_try</b> doesn't seem like a bad alternative.
<p>
Is it faster?  Let's see:

<pre>
UNIX> <font color=darkred><b>time sh -c 'for i in 1 2 3 4 5 6 ; do bin/sudoku5 < txt/test_puzzle_$i.txt > /dev/null; done'</b></font>
0.210u 0.010s 0:00.18 122.2%  0+0k 0+0io 0pf+0w
UNIX> <font color=darkred><b></b></font>
</pre>

Well, it runs in 50 percent of the time of <b>sudoku4</b>, so I guess I should
be happy.  I'm not really, but I'll pretend.  
There are lots of things to try -- for example, 
<b><a href=src/sudoku6.cpp>src/sudoku6.cpp</a></b>
creates <b>to_try</b> from the smallest of <b>vrows[r]</b>,
<b>vcols[c]</b> and
<b>vpanels[r/3][c/3]</b>:

<pre>
UNIX> <font color=darkred><b>time sh -c 'for i in 1 2 3 4 5 6 ; do bin/sudoku6 < txt/test_puzzle_$i.txt > /dev/null; done'</b></font>
0.190u 0.000s 0:00.17 111.7%  0+0k 0+0io 0pf+0w
UNIX> <font color=darkred><b></b></font>
</pre>

Let's try something else....

<hr>
<h3>Using integers and bit operations as sets</h3>

Before you read this, make sure you understand bit operations.
Please see 
<a href=http://web.eecs.utk.edu/~jplank/plank/classes/cs302/Notes/Bits/>the lecture 
notes on bit operations</a> if you need to brush up.
<p>
As illustrated in those lectures, you can use integers and bit operations to represent sets.
This actually simplifies the code above.  In
<b><a href=src/sudoku7.cpp>src/sudoku7.cpp</a></b>, we do this.  
(BTW, this code and the code in 
<b><a href=src/sudoku8.cpp>src/sudoku8.cpp</a></b> are of an older style, and a little
different than the code above -- you shouldn't have a hard time navigating them).
<p>
Actually, we do quite a bit more.  First, we use the numbers 1 through 9 in the puzzle rather than
their characters.  We represent '-' with 0.  
The sets are now vectors of integers rather than <b>sets</b>.  We also have the panel set be
a flat vector of nine elements.  We use the procedure <b>rctoindex()</b> to convert row and
column indices to a single index for this vector.
<p>

Now, to create the initial
sets for rows, columns and panels, we do the following:  We first create sets of the numbers that
are in each row/column/panel, and then we take their complement so that we have sets of the
numbers that are <i>not</i> in each row/column/panel:

<p><center><table border=3 cellpadding=3><td><pre>
// In the constructor:

  RS.resize(9, 0);
  CS.resize(9, 0);
  PS.resize(9, 0);

  for (i = 0; i &lt; 9; i++) {
    for (j = 0; j &lt; 9; j++) {
      if (P[i][j] != 0) {
        RS[i] |= (1 &lt;&lt; P[i][j]);
        CS[j] |= (1 &lt;&lt; P[i][j]);
        PS[rctoindex(i, j)] |= (1 &lt;&lt; P[i][j]);
      }
    }
  }

  for (i = 0; i &lt; 9; i++) {
    RS[i] = ~RS[i];
    CS[i] = ~CS[i];
    PS[i] = ~PS[i];
  }
}
</pre></td></table></center><p>

Then the solver takes the intersection of the three sets, and only puts elements that are
in that intersection into the recursive tester:

<p><center><table border=3 cellpadding=3><td><pre>
int Sudoku::Solve(int r, int c)
{
  int i, j;

  while (r &lt; 9) {
    while (c &lt; 9) {
      if (P[r][c] == 0) {
        j = (RS[r] & CS[c] & PS[rctoindex(r, c)]);   <font color=blue>// J is the intersection of the three sets</font>
        for (i = 1; i &lt;= 9; i++) {
          if (j & (1 &lt;&lt; i)) {

            P[r][c] = i;
            RS[r] &= (~(1 &lt;&lt; i));             <font color=blue>       // Remove bit i from RS, CS and PS</font>
            CS[c] &= (~(1 &lt;&lt; i));
            PS[rctoindex(r, c)] &= (~(1 &lt;&lt; i));

            if (Solve(r, c)) return 1;

            RS[r] |= (1 &lt;&lt; i);                <font color=blue>       // Put bit i back into RS, CS and PS</font>
            CS[c] |= (1 &lt;&lt; i);
            PS[rctoindex(r, c)] |= (1 &lt;&lt; i);
          }
        }
        P[r][c] = 0;
        return 0;
      }
      c++;
    }
    if (c == 9) { r++; c = 0; }
  }
  return 1;
}
</pre></td></table></center><p>

Now we're talking speed improvements!

<pre>
UNIX> <font color=darkred><b>g++ -O3 -o bin/sudoku7 src/sudoku7.cpp</b></font>
UNIX> <font color=darkred><b>time sh -c 'for i in 1 2 3 4 5 6 ; do bin/sudoku7 < txt/test_puzzle_$i.txt > /dev/null; done'</b></font>
0.070u 0.000s 0:00.02 350.0%  0+0k 0+0io 0pf+0w
UNIX> <font color=darkred><b></b></font>
</pre>

The improvement comes from the following reason -- for small sets, 
bit operations are <i>much</i> faster than using
balanced binary trees (which is how the STL implements sets).

<hr>
<h3>My final version (I don't do this in class)</h3>

Try 
<b><a href=src/sudoku8.cpp>src/sudoku8.cpp</a></b>.  I've made the following improvements here:

<UL>
<LI> I've added an array called <b>vecs</b>, which I index by the intersection of 
RS/CS/PS.  It contains an array of the elements of the set, terminated by zero.
Therefore, if the intersection is 0x92, meaning that elements 1, 4 and 7 are in the
intersection, then <b>vecs[0x92]</b> = { 1, 4, 7, 0 }.  This saves me time figuring
out what elements are in the set.

<LI> I've added a vector called <b>Empty_Cells</b>, which contains the row and
column indices of the empty cells in the puzzle.  That way I don't have to waste
time looking at non-empty cells.

<LI> I precalculate <b>rctoindex(r, c)</b> in case the compiler can't figure it out.
</UL>

That shaves another hundredth of a second off.  I'm guessing that the overhead of 
launching the program and reading the puzzle is getting in the way, but I'm sick
of twiddling with this......


