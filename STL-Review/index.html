<title>CS302 Lecture Notes</title>
<h2>CS302 Lecture Notes - STL Review with some Topcoder Problems </h2>
<UL>
<LI> August 28, 2012
<LI> Latest revision:
Tue Aug 23 13:57:44 EDT 2016
<LI> James S. Plank
<LI> Directory: <b>/home/plank/cs302/Notes/STL-Review</b>
</UL>

In class, we went over three topcoder problems.  In these lecture notes, 
I'll reiterate some points made in class.

<hr>
<h3>SRM 347, D2, 250-pointer: CarBuyer</h3>

Read over the problem.  It's on their web server at: <a href=http://community.topcoder.com/stat?c=problem_statement&pm=7652&rd=10671>http://community.topcoder.com/stat?c=problem_statement&pm=7652&rd=10671</a>.
I have a program that includes <b>CarBuyer.cpp</b> and lets you test the examples
in 
<b><a href=CB-Main.cpp>CB-Main.cpp</a></b>.  Compile and test by copying your implementation
to <b>CarBuyer.cpp</b> and then calling <b>g++ -std=c++98</b> on <b>CB-Main.cpp</b>:

<pre>
UNIX> <font color=darkred><b>cp CarBuyer-ss.cpp CarBuyer.cpp</b></font>
UNIX> <font color=darkred><b>vi CB-Main.cpp</b></font>
UNIX> <font color=darkred><b>g++ -std=c++98 CB-Main.cpp</b></font>
UNIX> <font color=darkred><b>./a.out 0</b></font>
10500.000000
UNIX> <font color=darkred><b>./a.out 1</b></font>
45200.000000
UNIX> <font color=darkred><b>./a.out 2</b></font>
254122.444444
UNIX> <font color=darkred><b></b></font>
</pre>

The reason I did this problem was to review stringstreams.  Solving this problem 
is pretty straightforward.  First, convert all of those ints to doubles, since you'll
be using floating point.  Next, for each string in <b>cars</b>, use a stringstream to
extract the price, tax and efficiency.  Then calculate the cost and store the minimum.
<p>
Some smaller points to remember:
<p>
<UL>
<LI> You have to clear the stringstream before you reuse it.
<LI> You don't have to error check, since Topcoder guarantees that your input is
correct.
<LI> Note that I extract the values in the stringstream as doubles.  Again, that is
because I'm doing floating point arithmetic, and we don't ever use floats, because
their precision is poor.
</UL>

Here's the code

(<b><a href=CarBuyer.cpp>CarBuyer.cpp</a></b>)

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;sstream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
using namespace std;

class CarBuyer {
  public:
    double lowestCost(vector &lt;string&gt; cars, int fuelPrice, int annualDistance, int years);
};

double CarBuyer::lowestCost(vector &lt;string&gt; cars, int fuelPrice, int annualDistance, int years)
{
  int i;
  istringstream ss;
  double fp, ad, y, price, tax, efficiency, cost, min;
 
  <font color=blue>/* Convert all of those integers to doubles. */</font>

  fp = fuelPrice;
  ad = annualDistance; 
  y = years;

  <font color=blue>/* Use a stringstream to extract the values from each string, 
     and compute the cost.  Keep track of the minimum cost. */</font>

  min = -1;
  for (i = 0; i &lt; cars.size(); i++) {
    ss.clear();
    ss.str(cars[i]);
    ss &gt;&gt; price &gt;&gt; tax &gt;&gt; efficiency;
    cost = price + (y * tax) + (y * ad * fp / efficiency);
    if (min == -1 || cost &lt; min) min = cost;
  }
  return min;
}
</pre></td></table></center><p>

In class, I showed you how to use <b>sscanf()</b> in place of the stringstream.  
Here's that code.  Since <b>sscanf()</b> does not use reference variables, you have
to pass pointers that get filled in.  I personally prefer <b>sscanf()</b> to stringstreams,
but that's mostly because I'm old and have been using <b>sscanf()</b> for 30+ years.  The
return value of <b>sscanf()</b> tells you how many matches were made correctly.  In this
program, that would be three, since Topcoder guarantees that your input is correct.

(This code is in
<b><a href=CarBuyer-sscanf.cpp>CarBuyer-sscanf.cpp</a></b>):

<p><center><table border=3 cellpadding=3><td><pre>
double CarBuyer::lowestCost(vector &lt;string&gt; cars, int fuelPrice, int annualDistance, int years)
{
  int i;

  double fp, ad, y, price, tax, efficiency, cost, min;
 
  fp = fuelPrice;
  ad = annualDistance; 
  y = years;
  min = -1;

  for (i = 0; i &lt; cars.size(); i++) {
    sscanf(cars[i].c_str(), "%lf %lf %lf", &price, &tax, &efficiency);
    cost = price + (y * tax) + (y * ad * fp / efficiency);
    if (min == -1 || cost &lt; min) min = cost;
  }
  return min;
}
</pre></td></table></center><p>

<h4>Bottom Lines From This Program</h4>

This was just about input processing: Practice with stringstreams and <b>sscanf()</b>.
<hr>
<h3>SRM 551, D2, 250-Pointer: ColorfulBricks</h3>

Go ahead and read the description from Topcoder or 
<a href=http://community.topcoder.com/stat?c=problem_statement&pm=12136&rd=15173>http://community.topcoder.com/stat?c=problem_statement&pm=12136&rd=15173</a>.
What you should see relatively 
quickly that this problem amounts to counting the number of distinct letters
in <b>bricks</b>.  If that number is two, return two.  If that number is one,
return one.  If that number is anything else, return zero.
<p>
Now, determining the number of distinct letters is an easy matter, and there
are a lot of ways to write <b>ColorfulBricks</b>.  In my opinion, the easiest
is to sort <b>bricks</b>, and then count the number of times adjacent letters
don't equal each other.  That's in 
<b><a href=Colorful-Sort.cpp>Colorful-Sort.cpp</a></b>. Remember, you need to
include <b>algorithm</b> to use the STL's <b>sort()</b> procedure.

<p><center><table border=3 cellpadding=3><td><pre>
int ColorfulBricks::countLayouts(string bricks)
{
  int i, nc;

  sort(bricks.begin(), bricks.end());

  nc =  1;
  for (i = 1; i &lt; bricks.size(); i++) if (bricks[i] != bricks[i-1]) nc++;
  if (nc == 1) return 1;
  if (nc == 2) return 2;
  return 0;
}
</pre></td></table></center><p>

To test this, copy it to <b>ColorfulBricks.cpp</b> and compile <b>Colorful-Main.cpp</b>:

<pre>
UNIX> <font color=darkred><b>cp Colorful-Sort.cpp ColorfulBricks.cpp</b></font>
UNIX> <font color=darkred><b>g++ -std=c++98 Colorful-Main.cpp </b></font>
UNIX> <font color=darkred><b>./a.out 0</b></font>
2
UNIX> <font color=darkred><b>./a.out 1</b></font>
1
UNIX> <font color=darkred><b>./a.out 2</b></font>
0
UNIX> <font color=darkred><b></b></font>
</pre>

Alternatively, you can use a <b>set</b> to store the characters in <b>bricks</b>, and
the size of the set will be the number of distinct characters.  This is in:
<b><a href=Colorful-Set.cpp>Colorful-Set.cpp</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
int ColorfulBricks::countLayouts(string bricks)
{
  int i;
  set &lt;char&gt; s;

  for (i = 0; i &lt; bricks.size(); i++) s.insert(bricks[i]);
  if (s.size() == 1) return 1;
  if (s.size() == 2) return 2;
  return 0;
}
</pre></td></table></center><p>

Remember, sets don't store duplicate values and maps don't store duplicate
keys -- use multisets and multimaps if you want that functionality.  Here,
we don't want duplicates.
<p>
You can use a map, too, instead of a set, which allows you to leverage the
syntax where you can treat the map like an associative array. 
That's in 
<b><a href=Colorful-Map.cpp>Colorful-Map.cpp</a></b>

<p><center><table border=3 cellpadding=3><td><pre>
int ColorfulBricks::countLayouts(string bricks)
{
  int i;
  map &lt;char, int&gt; s;

  <font color=blue>/* This treats the map like an associate array, inserting
     bricks[i] into the map if it is not there already. */</font>

  for (i = 0; i &lt; bricks.size(); i++) s[bricks[i]]++;

  if (s.size() == 1) return 1;
  if (s.size() == 2) return 2;
  return 0;
}
</pre></td></table></center><p>
<p>
You can instead leverage the fact that there are only
26 potential values of <b>bricks[i]</b>, to use a vector.
In the code below, (<b><a href=Colorful-Vec1.cpp>Colorful-Vec1.cpp</a></b>), we have a
vector <b>s</b>, where we set <b>s[i]</b> to one if <b>('A'+i)</b> is in the string:
Then you count up the elements of <b>s</b> which equal one:

<p><center><table border=3 cellpadding=3><td><pre>
int ColorfulBricks::countLayouts(string bricks)
{
  int i, nc;
  vector &lt;int&gt; s;

  s.resize(26, 0);
  nc = 0;
  for (i = 0; i &lt; bricks.size(); i++) s[bricks[i]-'A'] = 1;
  for (i = 0; i &lt; 26; i++) if (s[i] != 0) nc++;
  if (nc == 1) return 1;
  if (nc == 2) return 2;
  return 0;
}
</pre></td></table></center><p>

You can tweak the above to use the characters themselves as indices into
<b>s</b>
(<b><a href=Colorful-Vec2.cpp>Colorful-Vec2.cpp</a></b>).   The maximum character that
you'll see is 'Z', so that's why we resize <b>s</b> to be <tt>('Z'+1)</tt>.
<p>
<p><center><table border=3 cellpadding=3><td><pre>
int ColorfulBricks::countLayouts(string bricks)
{
  int i, nc;
  vector &lt;int&gt; s;

  s.resize('Z'+1, 0);
  nc = 0;
  for (i = 0; i &lt; bricks.size(); i++) s[bricks[i]] = 1;
  for (i = 'A'; i &lt;= 'Z'; i++) if (s[i] != 0) nc++;
  if (nc == 1) return 1;
  if (nc == 2) return 2;
  return 0;
}
</pre></td></table></center><p>

I'm not sure
which is easier to read -- this program of the last one.  They are both about the same to me.
<p>

Finally, you can simply use one variable to keep track of the first letter
and another to keep track of the second.  This is in 
<b><a href=Colorful-L1L2.cpp>Colorful-L1L2.cpp</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
int ColorfulBricks::countLayouts(string bricks)
{
  int i, l1, l2, n;
  vector &lt;int&gt; s;

  l1 = bricks[0];
  n = 1;
  
  for (i = 1; i &lt; bricks.size(); i++) {
    if (n == 1 && bricks[i] != l1) {
      n = 2;
      l2 = bricks[i];
    } else if (n == 2 && bricks[i] != l1 && bricks[i] != l2) return 0;
  }

  if (n == 1) return 1;
  if (n == 2) return 2;
  return 0;
}
</pre></td></table></center><p>

They all work, so which is the best?  I'll hedge a bit.  First, let's think about running
time complexity.  Suppose that there are <i>n</i> elements in <b>bricks</b>.  Then
the first three implementations are <i>O(n log n)</i>, while the remaining three
are <i>O(n)</i>.  That would argue for one of the last three.  In terms of raw
speed, the last one will be the fastest, because it exits quickly when you see the third
letter.  So is that the best?  
<p>Well, I'm hedging
because you need to consider multiple factors when you ask about the "best."
Speed is one thing.  Memory is another (the last one wins there too).  
Readability is a third (I think the <b>set</b> solution is the most readable).
And of course, in Topcoder, speed of programming and disinclination for bugs
is also important.  Since the constraints ensure that all implementations will
be super-fast (<i>n</i> is less than or equal to 50), these last considerations
may be the most important, in which case the one that used sorting is the best.
That's what I used when I solved this one for fun (it took 3 minutes for 246.70 points).
<p>
Regardless of which one is "best," you should be able to tell me the running time
of all of these.

<h4>Bottom Lines From This Program</h4>

There are many ways to solve a problem.  The ``best'' way depends on what is important
for the problem at hand, such as:

<UL>
<LI> Speed of the program
<LI> Memory consumption
<LI> Speed of the programming process
<LI> Readability of the code
<LI> Disinclination for bugs
</UL>

<hr>
<h3>SRM 353, D1, 250-pointer: Glossary</h3>

Go ahead and read the description, either on Topcoder or 
<a href=http://community.topcoder.com/stat?c=problem_statement&pm=7838&rd=10710>http://community.topcoder.com/stat?c=problem_statement&pm=7838&rd=10710</a>.
I know from experience that y'all hate these problems, because there's so 
much detail in the formatting.  However specifications are specifications.
What I'm going to do is build this one up and show you how I'd attack it.
There's a temptation to do everything at once -- build a big data structure
and then traverse it and print.  That really doesn't work well here.
Instead, it's better to go small, and build up, testing as you go.
<p>
The first thing to notice is that you have to sort the output, ignoring
case.  So, the first thing that I'm going to do is read all the terms,
convert them to uppercase, and then store them in a map.  The key will
be the uppercase term, and the val is the original term.  Then, I'll
print it out to make sure I've got it right.  This is in 
<b><a href=Glossary-1.cpp>Glossary-1.cpp</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
vector &lt;string&gt; Glossary::buildGlossary(vector &lt;string&gt; I)
{
  int i, j;
  string s;
  map &lt;string, string&gt; g;
  map &lt;string, string&gt;::iterator git;
  SVec rv;

  <font color=blue>/* Create the map g, which has the strings converted 
     to upper-case as keys, and the strings themselves as vals. */</font>

  for (i = 0; i &lt; I.size(); i++) {
    s = I[i];
    for (j = 0; j &lt; s.size(); j++) {
      if (s[j] &gt;= 'a' && s[j] &lt;= 'z') s[j] += ('A'-'a');
    }
    g[s] = I[i];
  }

  for (git = g.begin(); git != g.end(); git++) {
    cout &lt;&lt; git-&gt;first &lt;&lt; " " &lt;&lt; git-&gt;second &lt;&lt; endl;
  }
  return rv;
}
</pre></td></table></center><p>

Remember, the line "<b>g[s] = I[i]</b>" is equivalent to 
"<b>g.insert(make_pair(s, I[i]))</b>."  I return an empty vector so that
everything compiles nicely.  When we run it, it works as anticipated:

<pre>
UNIX> <font color=darkred><b>cp Glossary-1.cpp Glossary.cpp</b></font>
UNIX> <font color=darkred><b>g++ -std=c++98 Glossary-Main.cpp</b></font>
UNIX> <font color=darkred><b>./a.out 0</b></font>
CANADA Canada
FRANCE France
GERMANY Germany
ITALY Italy
JAPAN Japan
RUSSIA Russia
UNITED KINGDOM United Kingdom
UNITED STATES United States
UNIX> <font color=darkred><b>./a.out 1</b></font>
ALPHA alpha
BETA beta
DELTA delta
GAMMA gamma
OMEGA omega
UNIX> <font color=darkred><b></b></font>
</pre>

Next, I'm going to add a second map.  It has single characters as
its keys, and vectors of strings as vals.  These are the glossary entries.  Since
we create this by traversing <b>g</b>, we can be guaranteed that the vectors
are in the proper order.  We print it out in a format similar to what we
need, and test again.  It's in 
<b><a href=Glossary-2.cpp>Glossary-2.cpp</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
vector &lt;string&gt; Glossary::buildGlossary(vector &lt;string&gt; I)
{
  int i, j;
  string s;
  map &lt;string, string&gt; g;
  map &lt;string, string&gt;::iterator git;
  map &lt;char, SVec&gt; bychar;
  map &lt;char, SVec&gt;::iterator bit;
  char f;
  SVec rv;

  <font color=blue>/* Create the map g, which has the strings converted 
     to upper-case as keys, and the strings themselves as vals. */</font>
  
  for (i = 0; i &lt; I.size(); i++) {
    s = I[i];
    for (j = 0; j &lt; s.size(); j++) {
      if (s[j] &gt;= 'a' && s[j] &lt;= 'z') s[j] += ('A'-'a');
    }
    g[s] = I[i];
  }

  <font color=blue>/* Now, create the map "bychar", which has the starting
     letters as keys, and vectors of the original strings as vals. */</font>

  for (git = g.begin(); git != g.end(); git++) {
    f = git-&gt;first[0];
    bychar[f].push_back(git-&gt;second);
  }

  <font color=blue>/* Print out "bychar." */</font>

  for (bit = bychar.begin(); bit != bychar.end(); bit++) {
    printf("%c\n", bit-&gt;first);
    printf("-----\n");
    for (i = 0; i &lt; bit-&gt;second.size(); i++) {
      printf("  %s\n", bit-&gt;second[i].c_str());
    }
  }
    
  return rv;
}
</pre></td></table></center><p>

Now, instead of printing out those entries, let's create strings
from them that are in the proper format, and then put them into one of
two vectors -- a vector for A-M, and a vector for N-Z.  This is in 
<b><a href=Glossary-3.cpp>Glossary-3.cpp</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
vector &lt;string&gt; Glossary::buildGlossary(vector &lt;string&gt; I)
{
  int i, j;
  string s;
  map &lt;string, string&gt; g;
  map &lt;string, string&gt;::iterator git;
  map &lt;char, SVec&gt; bychar;
  map &lt;char, SVec&gt;::iterator bit;
  char f;
  SVec atm, ntz, rv, *v;
  char cs[100];

  <font color=blue>/* Create the map g, which has the strings converted 
     to upper-case as keys, and the strings themselves as vals. */</font>

  for (i = 0; i &lt; I.size(); i++) {
    s = I[i];
    for (j = 0; j &lt; s.size(); j++) {
      if (s[j] &gt;= 'a' && s[j] &lt;= 'z') s[j] += ('A'-'a');
    }
    g[s] = I[i];
  }

  <font color=blue>/* Now, create the map "bychar", which has the starting
     letters as keys, and vectors of the original strings as vals. */</font>

  for (git = g.begin(); git != g.end(); git++) {
    f = git-&gt;first[0];
    bychar[f].push_back(git-&gt;second);
  }

  <font color=blue>/* Create the formatted strings for each column.  Put the
     strings onto a vector for each column. */</font>

  for (bit = bychar.begin(); bit != bychar.end(); bit++) {
    v = (bit-&gt;first &lt; 'N') ? &atm : &ntz;
    s.clear();
    s.resize(19, ' ');
    s[0] = bit-&gt;first;
    v-&gt;push_back(s);
    s.clear();
    s.resize(19, '-');
    v-&gt;push_back(s);

    for (i = 0; i &lt; bit-&gt;second.size(); i++) {
      sprintf(cs, "  %-17s", bit-&gt;second[i].c_str());
      s = cs;
      v-&gt;push_back(s);
    }
  }

  <font color=blue>/* Print the vectors to error check. */</font>

  for (i = 0; i &lt; atm.size(); i++) cout &lt;&lt; atm[i] &lt;&lt; endl;
  cout &lt;&lt; endl;
  for (i = 0; i &lt; ntz.size(); i++) cout &lt;&lt; ntz[i] &lt;&lt; endl;
    
  return rv;
}
</pre></td></table></center><p>

A few things -- first, note how I use a pointer to an <b>SVec</b> to make
sure that I'm putting the strings onto the correct list.  Second, I'm using
<b>sprintf()</b> to create the strings for the terms.  I do that because it's
easier than using an <b>ostringstream</b>.  The only sublety is that I need to
make sure the memory is allocated for <b>cs</b>.  It could be only 20 characters
(19 for the string and one for the null character, but I'm using 100 just to
be safe.  The string "  %-17s" says to create the string with two spaces, and
then pad the argument to 17 characters, left justified.  That makes the resulting
string 19 characters.  Saying "<b>s = cs</b>" creates a C++ string from <b>cs</b>.
<p>
When we compile and run it, all looks good.  We can pipe the output to <b>cat -A</b>
to make sure that all of the strings are 19 characters:

<pre>
UNIX> <font color=darkred><b>cp Glossary-3.cpp Glossary.cpp</b></font>
UNIX> <font color=darkred><b>g++ -std=c++98 Glossary-Main.cpp </b></font>
UNIX> <font color=darkred><b>./a.out 0 | cat -A</b></font>
C                  $
-------------------$
  Canada           $
F                  $
-------------------$
  France           $
G                  $
-------------------$
  Germany          $
I                  $
-------------------$
  Italy            $
J                  $
-------------------$
  Japan            $
$
R                  $
-------------------$
  Russia           $
U                  $
-------------------$
  United Kingdom   $
  United States    $
UNIX> <font color=darkred><b></b></font>
</pre>

Finally, let's create <b>rv</b>.  The first thing we do is make sure that
both <b>atm</b> and <b>ntz</b> are the same size, by adding 19-character
strings to the smaller one.  Then we simply traverse them and create 
the strings in <b>rv</b> using string concatenation.  The final
program is in 
<b><a href=Glossary-4.cpp>Glossary-4.cpp</a></b>.  I only include the loop
that creates <b>rv</b>:

<p><center><table border=3 cellpadding=3><td><pre>
vector &lt;string&gt; Glossary::buildGlossary(vector &lt;string&gt; I)
{
  .......

  <font color=blue>/* Make atm and ntz the same size. */</font>

  s.clear();
  s.resize(19, ' ');
  while (atm.size() &lt; ntz.size()) atm.push_back(s);
  while (ntz.size() &lt; atm.size()) ntz.push_back(s);

  s = "  ";
  for (i = 0; i &lt; atm.size(); i++) {
    rv.push_back(atm[i] + s + ntz[i]);
  }
  return rv;
}
</pre></td></table></center><p>

<pre>
UNIX> <font color=darkred><b>cp Glossary-4.cpp Glossary.cpp</b></font>
UNIX> <font color=darkred><b>g++ -std=c++98 Glossary-Main.cpp</b></font>
UNIX> <font color=darkred><b>./a.out 0 | cat -A</b></font>
C                    R                  $
-------------------  -------------------$
  Canada               Russia           $
F                    U                  $
-------------------  -------------------$
  France               United Kingdom   $
G                      United States    $
-------------------                     $
  Germany                               $
I                                       $
-------------------                     $
  Italy                                 $
J                                       $
-------------------                     $
  Japan                                 $
UNIX> <font color=darkred><b>./a.out 1 | cat -A</b></font>
A                    O                  $
-------------------  -------------------$
  alpha                omega            $
B                                       $
-------------------                     $
  beta                                  $
D                                       $
-------------------                     $
  delta                                 $
G                                       $
-------------------                     $
  gamma                                 $
UNIX> <font color=darkred><b>./a.out 2 | cat -A</b></font>
A                                       $
-------------------                     $
  array                                 $
  AVL tree                              $
B                                       $
-------------------                     $
  backtracking                          $
  balanced tree                         $
  binary search                         $
UNIX> <font color=darkred><b>./a.out 3 | cat -A</b></font>
                     X                  $
                     -------------------$
                       XXXXXXXXXXXXXXXXX$
                     Y                  $
                     -------------------$
                       YYYYYYYYYYYYYYYYY$
                     Z                  $
                     -------------------$
                       ZZZZZZZZZZZZZZZZZ$
UNIX> <font color=darkred><b>./a.out 4 | cat -A</b></font>
A                    O                  $
-------------------  -------------------$
  Asteria              Oceanus          $
  Astraeus             Ophion           $
  Atlas              P                  $
C                    -------------------$
-------------------    Phoebe           $
  Clymene              Prometheus       $
  Coeus              R                  $
  Crius              -------------------$
  Cronus               Rhea             $
D                    T                  $
-------------------  -------------------$
  Dione                Tethys           $
E                      Theia            $
-------------------    Themis           $
  Epimetheus                            $
H                                       $
-------------------                     $
  Helios                                $
  Hyperion                              $
I                                       $
-------------------                     $
  Iapetus                               $
L                                       $
-------------------                     $
  Leto                                  $
M                                       $
-------------------                     $
  Mnemosyne                             $
UNIX> <font color=darkred><b></b></font>
</pre>

Time to submit!!
<p>
<h4>Bottom Lines From This Program</h4>
<UL>
<LI> All that picayune formatting really wasn't that bad.  Moreover, I never had
to count to 17 or 19 -- I used <b>resize()</b> and <b>sprintf()</b> to do the
dirty work for me.
<LI> It's always good to build and test, build and test, build and test.
<LI> Organize your data into effective data structures.  That can make the job of
doing weird output much easier.
</UL>

<hr>
<h3>Review of STL Running Times</h3>

<center>
<table border=3 cellpadding=5>
<tr>
<td></td>
<td align=center><b>vector</b></td>
<td align=center><b>deque</b></td>
<td align=center><b>list</b></td>
<td align=center><b>set</b></td>
<td align=center><b>map</b></td>
</tr>
<tr>
<td align=center valign=top><U>Accessing with an index</u><br><tt>v[i]</tt></td>
<td align=center><i>O(1)</i></td>
<td align=center><i>O(1)</i></td>
<td align=center>Not supported</td>
<td align=center>Not supported</td>
<td align=center>Not supported</td>
</tr>
<tr>
<td align=center valign=top><U>Appending</u><br><tt>push_back()</tt></td>
<td align=center><i>O(1)</i></td>
<td align=center><i>O(1)</i></td>
<td align=center><i>O(1)</i></td>
<td align=center>Not supported</td>
<td align=center>Not supported</td>
</tr>
<tr>
<td align=center valign=top><U>Prepending</u><br><tt>push_front()</tt><br><tt>v.insert(v.begin(),...)</tt></td>
<td align=center><i>O(n)</i></td>
<td align=center><i>O(1)</i></td>
<td align=center><i>O(1)</i></td>
<td align=center>Not supported</td>
<td align=center>Not supported</td>
</tr>
<tr>
<td align=center valign=top><U>General Insertion</u></td>
<td align=center><i>O(n)</i></td>
<td align=center><i>O(n)</i></td>
<td align=center><i>O(1)</i></td>
<td align=center><i>O(log n)</i></td>
<td align=center><i>O(log n)</i></td>
</tr>
<tr>
<td align=center valign=top><U>Deleting from the back</u><br><tt>pop_back()</tt><br><tt>v.erase(v.rbegin())</tt></td>
<td align=center><i>O(1)</i></td>
<td align=center><i>O(1)</i></td>
<td align=center><i>O(1)</i></td>
<td align=center><i>O(log n)</td>
<td align=center><i>O(log n)</td>
</tr>
<td align=center valign=top><U>Deleting from the front</u><br><tt>pop_front()</tt><br><tt>v.erase(v.begin())</tt></td>
<td align=center><i>O(n)</i></td>
<td align=center><i>O(1)</i></td>
<td align=center><i>O(1)</i></td>
<td align=center><i>O(log n)</td>
<td align=center><i>O(log n)</td>
</tr>
<tr>
<tr>
<td align=center valign=top><U>General Deletion</u></td>
<td align=center><i>O(n)</i></td>
<td align=center><i>O(n)</i></td>
<td align=center><i>O(1)</i></td>
<td align=center><i>O(log n)</i></td>
<td align=center><i>O(log n)</i></td>
</tr>
<tr>
<td align=center valign=top><U>Finding an element</u></td>
<td align=center><i>O(n)</i></td>
<td align=center><i>O(n)</i></td>
<td align=center><i>O(n)</i></td>
<td align=center><i>O(log n)</i></td>
<td align=center><i>O(log n)</i></td>
</tr>
<tr>
<td align=center valign=top><U>Traversing</u></td>
<td align=center><i>O(n)</i></td>
<td align=center><i>O(n)</i></td>
<td align=center><i>O(n)</i></td>
<td align=center><i>O(n)</i></td>
<td align=center><i>O(n)</i></td>
</tr>
<tr>
<td align=center valign=top><U>Clearing</u><br><tt>v.clear()</tt></td>
<td align=center><i>O(1)</i></td>
<td align=center><i>O(1)</i></td>
<td align=center><i>O(n)</i></td>
<td align=center><i>O(n log n)</i></td>
<td align=center><i>O(n log n)</i></td>
</tr>
<tr>
<td align=center valign=top><U>Creating from <i>n</i> elements</u></td>
<td align=center>Using a loop with <br><tt>push_back()</tt>:<br><i>O(n)</i></td>
<td align=center>Using a loop with <br><tt>push_back()</tt>:<br><i>O(n)</i></td>
<td align=center>Using a loop with <br><tt>push_back()</tt>:<br><i>O(n)</i></td>
<td align=center>Using a loop with <br><tt>insert()</tt>:<br><i>O(n log n)</i></td>
<td align=center>Using a loop with <br><tt>insert()</tt>:<br><i>O(n log n)</i></td>
</tr>
</table>
</center>
<p>

